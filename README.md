# PR Reviewer Assignment Service 

Сервис для автоматического назначения ревьюверов на Pull Request’ы внутри команды.

## Запуск

### Требования

- Docker и docker-compose
- (Опционально) Go 1.25+ и make — только если хотите запускать сервис локально без Docker

### 1. Клонирование репозитория

```bash
git clone https://github.com/enfantsrichesdepress1on/Backend-trainee-assignment-autumn-2025.git

### 2. Start / stop

```bash
# вариант без make
docker-compose up --build

# или, если установлен make
make docker-up
```

```bash
# без make
docker-compose down

# или
make docker-down
```

### 3. Tests

```bash
# через make
make test

# или напрямую
go test ./...
```

## Problem --> solution 

### Коды ошибок BAD_REQUEST и INTERNAL.

В OpenAPI-спецификации описан общий формат ошибки (ErrorResponse) и набор доменных кодов: TEAM_EXISTS, PR_EXISTS, PR_MERGED, NOT_ASSIGNED, NO_CANDIDATE, NOT_FOUND

В реализации сервиса я дополнительно использую коды:
- BAD_REQUEST — для ошибок парсинга входного запроса (ошибки JSON, некорректные поля, несоответствие схеме и т.п.).
- INTERNAL — для неожиданных внутренних ошибок сервера, которые не относятся к доменным ошибкам.

Эти коды не описаны в исходном openapi.yaml, но используют тот же формат ErrorResponse.

Добавлены чтобы -
- Явно разделить доменные ошибки от технических.
- Не «размазывать» ошибки парсинга по тексту message без кода.
- Сохранить единый формат ошибки для клиента.

### Фильтрация кандидатов на ревьюверов в service-layer, а не в storage-layer

В хранилище пользователей оставлен метод:

ListActiveUserByTeam(ctx, teamName string) ([]domain.User, error)

Он отвечает только за то, чтобы вернуть всех пользователей конкретной команды, у которых is_active = true. 
А исключение автора PR и уже назначенных ревьюверов производится в сервисном слое, а не в хранилище.

Считаю что правило «кто именно не может быть ревьювером» — это бизнес-логика, а не ответственность слоя хранения, репозиторий остаётся более универсальным: он знает только про факты (team_name, is_active), а не про доменные правила выбора ревьюверов.

Решил вынести это как проблему, так как в условиях большого объёма данных выгружение в память могло сильно влиять, но при наших обьёмах SLA не страдает.

### Инициализация зависимостей в main, а не в отдельном пакете

Инициализацию всех зависимостей (создание соединения с БД, инициализация хранилищ, сервиса, HTTP-обработчиков и роутера) я сознательно оставил в cmd/app/main.go, а не выносил в отдельный «композиционный» пакет.
Сервис получился слишком маленький, считаю что комопизионный пакет был бы лишним.
